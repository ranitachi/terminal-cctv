function cekdata()
	{
		$folder = "D:/JOB/RAMTEC/CCTV/Terbaru/";
		$data=array(
			"giwangan" => array(
				"jg1"=>"0c448fac-f403-411f-a99a-90cd17441361",
				"jg2"=>"5f50deaf-aac8-4eff-a82f-25274aeb5a8d",
				"jg4"=>"f8124a62-8e3c-4b99-afba-fa900cf9ff10","jg5"=>"3f2fbf63-368f-452e-8424-137c88613403","jg6"=>"6df639cc-9b34-4cc3-8062-23d650c576d5"),
			"soekarno" => array(
				"kl1"=>"b1db04ab-d030-4f77-9272-c7d97ed70e6a",
				"kl2"=>"7fa65726-40e1-42e5-b439-afb1b9fdcf66",
				"kl3"=>"cd52de4a-9a6c-497e-806d-5a0e17d4dc53",
				"kl4"=>"19ac5477-db64-4339-81ca-eeccdb852405",
				"kl5"=>"edb56316-2488-4221-bcdd-bfdaa61ae066",
				"kl6"=>"bb7ded47-4fa6-491a-a618-e0dd424817eb"),
			"tirtonadi" => array(
				"sl1"=>"51302a4b-5ea4-4d54-a884-dfe29747f780",
				"sl2"=>"552485c5-27f0-4d8f-9389-5f687cf1e548",
				"sl3"=>"dd72020b-18a8-49f9-a1cd-605f00220508",
				"sl4"=>"4d0783ac-0d68-4c45-8440-451a2a55c7ce",
				"sl5"=>"304c3c86-73ed-4d2c-a25a-4edad14ef9a5",
				"sl6"=>"8dce6c88-eb46-402e-8307-ac6ff7cd7de2"),
			"purabaya"=>array(
				"sd1"=>"9a98fa5e-c9d2-40e6-9a9f-e6f049a13fc2",
				"sd2"=>"0334245e-79f3-42eb-8bda-ad991935ce43",
				"sd3"=>"f440687e-722f-4797-b95d-bf5bceefbc94",
				"sd4"=>"b18c5818-d3f8-444e-b057-1d6c9d9eec5c",
				"sd5"=>"9df51a27-dba8-4318-8f6f-46bbb8243146",
				"sd6"=>"74b5e886-2da2-4607-b8d1-b09c28e296f8")
		);

		foreach ($data as $k => $v) 
		{
			echo $k.'<br>';
			foreach ($v as $kv => $vv) 
			{
				$listfile['acsm'] = null;
				$fol=$folder.$vv.'/';
				echo $fol.'<br>';
				$files = $this->getFileListNew($fol, $listfile);
				echo '<pre>';
				print_r($files);
				echo '</pre>';
				// echo $kv.'=>'.$vv.'<br>';
			}
		}
	}

	function getFileListNew($dir, &$listfile = array())
	{
		$extList = array("acsm");
		// print_r($extList);
		$files = scandir($dir);
		foreach($files as $key => $value){
			$path = realpath($dir.DIRECTORY_SEPARATOR.$value);
			if(!is_dir($path)) 
			{
				// echo ceil(filesize($path)/1024).'<br>';
				if(in_array(strtolower(pathinfo($path, PATHINFO_EXTENSION)), $extList))
				{
					
						$filename = pathinfo($path, PATHINFO_FILENAME);
						$listfile[strtolower(pathinfo($path, PATHINFO_EXTENSION))]['n'.str_replace(' ', '', str_replace('-', '', str_replace('_', '', $filename)))] = $path;
				}
			} else if($value != "." && $value != "..") {
				$this->getFileListNew($path, $listfile);
				
				if(in_array(strtolower(pathinfo($path, PATHINFO_EXTENSION)), $extList))
				{
						$filename = pathinfo($path, PATHINFO_FILENAME);
						$listfile[strtolower(pathinfo($path, PATHINFO_EXTENSION))]['n'.str_replace(' ', '', str_replace('-', '', str_replace('_', '', $filename)))] = $path;
				}
			}
		}

		return $listfile;
	}

	
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
<?php
 
if (is_file($file)) {
 
	header("Content-type: $mime_type");
 
	if (isset($_SERVER['HTTP_RANGE']))  { // do it for any device that supports byte-ranges not only iPhone
	
		rangeDownload($file);
	}
	else {
	
		header("Content-Length: ".filesize($file));
		readfile($file);
	}
 
else {
 
	// some error...
 
}
 
function rangeDownload($file) {
 
	$fp = @fopen($file, 'rb');
 
	$size   = filesize($file); // File size
	$length = $size;           // Content length
	$start  = 0;               // Start byte
	$end    = $size - 1;       // End byte
	// Now that we've gotten so far without errors we send the accept range header
	/* At the moment we only support single ranges.
	 * Multiple ranges requires some more work to ensure it works correctly
	 * and comply with the spesifications: http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.2
	 *
	 * Multirange support annouces itself with:
	 * header('Accept-Ranges: bytes');
	 *
	 * Multirange content must be sent with multipart/byteranges mediatype,
	 * (mediatype = mimetype)
	 * as well as a boundry header to indicate the various chunks of data.
	 */
	header("Accept-Ranges: 0-$length");
	// header('Accept-Ranges: bytes');
	// multipart/byteranges
	// http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.2
	if (isset($_SERVER['HTTP_RANGE'])) {
	
		$c_start = $start;
		$c_end   = $end;
		// Extract the range string
		list(, $range) = explode('=', $_SERVER['HTTP_RANGE'], 2);
		// Make sure the client hasn't sent us a multibyte range
		if (strpos($range, ',') !== false) {
		
			// (?) Shoud this be issued here, or should the first
			// range be used? Or should the header be ignored and
			// we output the whole content?
			header('HTTP/1.1 416 Requested Range Not Satisfiable');
			header("Content-Range: bytes $start-$end/$size");
			// (?) Echo some info to the client?
			exit;
		}
		// If the range starts with an '-' we start from the beginning
		// If not, we forward the file pointer
		// And make sure to get the end byte if spesified
		if ($range0 == '-') {
		
			// The n-number of the last bytes is requested
			$c_start = $size - substr($range, 1);
		}
		else {
		
			$range  = explode('-', $range);
			$c_start = $range[0];
			$c_end   = (isset($range[1]) && is_numeric($range[1])) ? $range[1] : $size;
		}
		/* Check the range and make sure it's treated according to the specs.
		 * http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html
		 */
		// End bytes can not be larger than $end.
		$c_end = ($c_end > $end) ? $end : $c_end;
		// Validate the requested range and return an error if it's not correct.
		if ($c_start > $c_end || $c_start > $size - 1 || $c_end >= $size) {
		
			header('HTTP/1.1 416 Requested Range Not Satisfiable');
			header("Content-Range: bytes $start-$end/$size");
			// (?) Echo some info to the client?
			exit;
		}
		$start  = $c_start;
		$end    = $c_end;
		$length = $end - $start + 1; // Calculate new content length
		fseek($fp, $start);
		header('HTTP/1.1 206 Partial Content');
	}
	// Notify the client the byte range we'll be outputting
	header("Content-Range: bytes $start-$end/$size");
	header("Content-Length: $length");
 
	// Start buffered download
	$buffer = 1024 * 8;
	while(!feof($fp) && ($p = ftell($fp)) <= $end) {
	
		if ($p + $buffer > $end) {
		
			// In case we're only outputtin a chunk, make sure we don't
			// read past the length
			$buffer = $end - $p + 1;
		}
		set_time_limit(0); // Reset time limit for big files
		echo fread($fp, $buffer);
		flush(); // Free up memory. Otherwise large files will trigger PHP's memory limit.
	}
 
	fclose($fp);
                  
}
?>